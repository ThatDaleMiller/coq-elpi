/* induction principles                                                      */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

shorten std.{do!, assert!, last, appendR, rev, map}.

namespace derive.induction {


% we cut since copy generates many solutions
pred subst i:term, o:term.
subst A B :- copy A B, !.

% local db associating to each constructor the hypothesis to be used
type induction-hyp-db term -> term -> prop.

% prove H G P finds a P : H => G
pred prove i:term, i:term, o:term.
prove H G P :- param1-functor-db H G P.

% prove-arg AppliedHyp AppliedGoal Argument ProofAppliedHyp Proof.
pred prove-arg i:term, i:term, i:term, i:term, o:term.

prove-arg X X _ P P :- !.

prove-arg (app [H|Hs]) (app[G|Gs]) X PHX PGX :-
  appendR HArgs [X] Hs, coq.mk-app H HArgs Hyp,
  appendR GArgs [X] Gs, coq.mk-app G GArgs Goal,
  prove Hyp Goal Proof,
  coq.mk-app Proof [X,PHX] PGX.

prove-arg (prod _ X x\ prod _ (PX x) (H x)) (prod _ _ y\ prod _ (PX y) (G y)) A PA (fun `x` X x\ fun `px` (PX x) (Proof x)) :- 
  pi x px\
    prove-arg (H x px) (G x px) {coq.mk-app A [x]} {coq.mk-app PA [x,px]} (Proof x px).
 
pred prove-args i:list term, i:list term, o:list term.
prove-args [] [] [].
prove-args [X,Pr|Args] [_,PX|ArgsT] [X,Proof|QArgs] :-
  subst PX Goal,
  prove-arg PX Goal X Pr Proof, !,
  prove-args Args ArgsT QArgs.  

% create (param1-functor-db (is_T params) P IH)
pred mk-map-isT-P-clause i:list term, i:term, i:term, i:term, o:prop.
mk-map-isT-P-clause [_] T P IH (param1-functor-db T P IH).

mk-map-isT-P-clause [_,_|Args] T P IH (pi x y\ C x y) :-
  pi x y\ mk-map-isT-P-clause Args {coq.mk-app T [x,y]} {coq.mk-app P [x,y]} {coq.mk-app IH [x,y]} (C x y).

% branch for constructor k is (hyp-k ...) where ... are the terms
% generated by prove-args
pred branch i:term, i:term, i:list term, i:list term, o:term. 
branch K _ V VT R :-
  induction-hyp-db K IH,
  prove-args V VT Args,
  coq.mk-app IH Args R,
  coq.typecheck R _ ok, !.

pred oty i:term, i:list term, i:list term, o:term.
oty _ _ VT P :-
  last VT XT,
  subst XT P.

pred branches i:term, i:term, i:list term, i:term, i:int, o:int, o:term, o:term.
branches (prod Name S T) Ity Args IH N M (prod Name S F1) (fun Name S R1) :- !,
  @pi-decl Name S x\
    branches (T x) Ity [x|Args] IH {calc (N + 1)} M (F1 x) (R1 x).

branches (sort _) Ity Args IH Rno Rno Fty (fun `x` ItyArgs Bo) :- do! [
  coq.mk-app Ity {rev Args} ItyArgs,
  subst ItyArgs PArgs,
  Fty = prod `x` ItyArgs (_\ PArgs),
  subst Ity P,
  mk-map-isT-P-clause Args Ity P IH C,
  @pi-decl `x` ItyArgs x\
    C =>
    coq.build-match x ItyArgs oty branch (Bo x)
].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Synthesize the type of each hypothesis starting from the type
% of the constructor of is_T

pred hyp i:term, o:term.
hyp (prod N S T) (prod N Q R) :- !,
  subst S Q,
  @pi-decl N Q x\ hyp (T x) (R x).
hyp S Q :- subst S Q.

pred hyps i:list term, i:list term, i:term, i:term, o:term.
hyps [K|KS] [KT|KTS] Ity Arity (fun Name Ind Bo) :-
  coq.term->gref K GRK,
  coq.name-suffix `H` {coq.gref->id GRK} Name,
  hyp KT Ind, !, % we cut since copy generates many solutions
  @pi-decl `Name` Ind x\
    induction-hyp-db K x => % This is the hyp to be used for branch K
    hyps KS KTS Ity Arity (Bo x).

hyps [] [] Ity Arity (fix `IH` Recno Fty Bo) :-
  @pi-decl `IH` Fty f\ sigma C\
    branches Arity Ity [] f 0 Recno Fty (Bo f).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameters and the P of the induction predicate (truncated wrt the type
% of the unary parametricity translation, eg P takes only the indexes)

pred truncated-predicate-ty i:term, o:term.
truncated-predicate-ty (sort _) T :-
  T = sort (typ U), coq.univ.new [] U.
truncated-predicate-ty (prod N S T) (prod N S R) :-
  pi x\ truncated-predicate-ty (T x) (R x).
  
% loads the context with the substitution "is_T params -> P"
pred mk-subst-clause i:term, i:term, o:list prop.
mk-subst-clause Ity P C :-
 coq.safe-dest-app Ity IT ITArgs,
 C = [(copy IT P :- !),
      (pi Args Rest O\
        copy (app[IT|Args]) O :- !, appendR ITArgs Rest Args, coq.mk-app P Rest O)].

pred params i:int, i:term, i:list term, i:list term, i:term, o:term.
params N Ity K KT (prod Nx Sx x\ prod NP (SP x) (T x)) (fun Nx Sx x\ fun NP (SP x) (R1 x)) :- N > 0, !,
  M is N - 2,
  @pi-decl Nx Sx x\
  @pi-decl NP (SP x) px\
    % useless, the identity map is already there
    % param1-functor-db px px (fun `x` x a\ fun `pa` (app[px,a]) pa\ pa) =>
    params M
      {coq.mk-app Ity [x,px]}
      {map K (k\ coq.mk-app k [x,px])}
      {map KT (coq.subst-prod [x,px])}
      (T x px) (R1 x px).

params 0 Ity K KT Arity (fun `P` Pty p\ Bo p) :-
  % P only takes the indexes of Arity
  truncated-predicate-ty Arity Pty,
  @pi-decl `P` Pty p\ sigma Subst\
    (mk-subst-clause Ity p Subst,
     % replace (is_T params) with P
     Subst =>
       hyps K KT Ity Arity (Bo p)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred main i:inductive, i:string, o:list prop.
main GR Name [Clause] :- do! [
  coq.env.global (indt GR) T,
  assert! (reali T TR) {calc (
    "derive.induction: no unary parametricity translation for" ^
    {coq.term->string T} ^ ", use derive.param1 first")},
  TR = global (indt GRR) UI,
  coq.env.indt GRR UI Ind Lno _ Arity K KT,
  assert! (Ind = tt) "derive.induction: Coinductive types are not supported",

  % we build the induction principle
  params Lno TR {std.map K (k\r\ r = global (indc k) UI)} KT Arity R,
  std.assert-ok! (coq.typecheck R RT) "derive.induction generates illtyped term",

  coq.env.add-const Name R RT _ I,

  % we register it as a clause
  Clause = (pi u\ induction-db GR (global (const I) u) :- !),
  coq.elpi.accumulate _ "derive.induction.db" (clause _ (before "induction-db:fail") Clause)
].

}
